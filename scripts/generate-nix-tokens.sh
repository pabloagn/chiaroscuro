#!/usr/bin/env bash

# scripts/generate-nix-tokens.sh

# This script generates the Nix tokens from the raw SCSS tokens.

set -euo pipefail

CSS_INPUT_FILE="${1:-dist/chiaroscuro.css}"
NIX_OUTPUT_FILE="${2:-dist/chiaroscuro.nix}"

if [ ! -f "$CSS_INPUT_FILE" ]; then
  echo "Error: CSS input file '$CSS_INPUT_FILE' not found."
  echo "Please compile the SCSS first (e.g., npm run build:css or sass src/main.scss $CSS_INPUT_FILE)"
  exit 1
fi

echo "Generating Nix tokens from $CSS_INPUT_FILE to $NIX_OUTPUT_FILE..."

# Start the Nix expression
cat >"$NIX_OUTPUT_FILE" <<EOF
# Generated Nix expression for Phantom Theme Tokens
# Do not edit this file directly. It is generated by scripts/generate-nix-tokens.sh
# from ${CSS_INPUT_FILE}

{
EOF

grep -E -- '--[a-zA-Z0-9-]+:.+;' "$CSS_INPUT_FILE" |
  awk -F':' '{
    gsub(/^--/, "", $1);
    gsub(/^[ \t]+|[ \t]+$/, "", $1);
    gsub(/^[ \t]+|[ \t]+;$/, "", $2);
    print $1 "<SEP>" $2
  }' |
  awk -F'<SEP>' '
  function start_attr(name, indent_level) {
    for (i = 0; i < indent_level; i++) printf "  ";
    # Quote attribute names if they are purely numeric or contain special chars
    # For simplicity now, quote if it looks like a number or is not a simple identifier
    if (name ~ /^[0-9]+$/ || name !~ /^[a-zA-Z_][a-zA-Z0-9_]*$/) {
      printf "\"%s\" = ", name;
    } else {
      printf "%s = ", name;
    }
  }

  function print_value(value) {
    # Quote string values, handle rgba specifically if needed later
    # For now, all CSS values are treated as strings
    # Escape existing double quotes in the value
    gsub(/"/, "\\\"", value);
    printf "\"%s\";\n", value;
  }

  BEGIN {
    # Max depth of nesting, e.g., color-archangel-50 is 3 levels
    # This helps manage closing braces correctly.
    # This is a simplified approach. A proper parser would build a tree.
    FS = "-"; # Split the variable name by hyphen
    OFS = "";
    print "  tokens = {"; # Top-level attribute for all tokens
    current_path[0] = ""; # Placeholder
  }

  {
    # $1 is the full original name (e.g., color-archangel-50)
    # $2 is the value (e.g., #ffffff)
    # Reconstruct full name for processing
    full_var_name = $1;
    css_value = $2;

    # Split the variable name parts
    n_parts = split(full_var_name, parts, "-");

    # Determine current indentation level and print path changes
    # This logic needs to be robust to handle path changes
    # For each part, check if it differs from the previous line path
    new_depth = 0;
    for (p_idx = 1; p_idx <= n_parts -1; ++p_idx) { # Iterate through path segments
        new_depth++;
        if (parts[p_idx] != current_path[new_depth] || new_depth > last_depth) {
            # If path segment changed or we are deeper, open new attrset
            # First, close any deeper attrsets from previous line
            for (d = last_depth; d > new_depth -1 && d > 0; --d) {
                for(i=0; i < d; ++i) printf "  ";
                printf "};\n";
            }
            start_attr(parts[p_idx], new_depth + 1); # +1 for the outer "tokens" and one more for current
            printf "{\n";
            current_path[new_depth] = parts[p_idx];
            # Clear deeper path segments from previous line
            for (d = new_depth + 1; d <= last_depth_max; ++d) current_path[d]="";

        }
    }


    # Print the actual variable (the last part of the name)
    indent = n_parts + 1; # +1 for the outer "tokens"
    start_attr(parts[n_parts], indent);
    print_value(css_value);

    last_depth = n_parts -1; # Depth of the parent attrset
    if (last_depth > last_depth_max) last_depth_max = last_depth;
  }

  END {
    # Close any remaining open attrsets
    for (d = last_depth; d >= 1; --d) {
        for(i=0; i < d + 1; ++i) printf "  "; # +1 for "tokens"
        printf "};\n";
    }
    print "  };"; # Close the top "tokens" attrset
  }
' >>"$NIX_OUTPUT_FILE"

# Close the main Nix expression
echo "}" >>"$NIX_OUTPUT_FILE"

echo "Nix tokens successfully generated!"
